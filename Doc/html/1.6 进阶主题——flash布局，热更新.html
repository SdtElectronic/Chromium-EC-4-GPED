
<h2>EC在flash中的布局</h2>
    <ul>
        <li>完成前几次的编译后，细心的读者可能会注意到得到的二进制相当大。回想起引言里鼓吹的EC的轻量特性，这似乎是彻头彻尾的虚假宣传啊？</li>
        <li>如果我们细心的读者还能再细心一点的话，他就会注意到，这些不同程序最终的编译结果有相同的大小——恰好是设定的FLASH的大小！</li>
        <li>我们细心的读者眉头一皱，发现事情并不简单。这说明最后得到的二进制的大小不是实际可执行程序的大小，这是为什么呢？</li>
        <li>实际上这是EC的flash布局产生的结果。EC默认会把设定的flash空间等分为只读（RO）和读写（RW）两部分，然后填充满整个空间</li>
        <li>在RO和RW区域同时存在两份几乎相同的程序，唯一的区别就是偏移地址不同</li>
        <li>EC采取这种flash布局有保证安全和固件热更新两个目的，有关热更新的知识在下一段介绍</li>
    </ul>
<h2>EC热更新</h2>
    <ul>

    </ul>
<h2>……可是我并不需要这样的特性</h2>
    <ul>
        <li>显然这个对chromebook意义重大的特性对于大多数嵌入式应用来说然并卵，反而让可用的程序空间直接打了五折</li>
        <li>我们希望能直接避开这个特性来获得一份RO区域的二进制。很遗憾，我并没有在官方的文档中找到编译参数或者宏设定之类的操作来达到这个目的</li>
        <li>我个人摸索到的一个方法是，在编译结果的目录下的RO子目录中，会有一个ec.RO.flat文件。通过和最终的ec.bin进行比对，可以确定它就是RO区域的程序</li>
        <li>直接烧写这个文件是不能让程序正常工作的，需要将其拓展名修改为bin，如ec.RO.bin，然后再进行烧写</li>
        <li>因为这个二进制的大小和实际程序相同，你会注意到烧写过程快了很多</li>
        <li>但是仅这样还不足以解决可用空间折半的问题，因为EC会进行编译期空间检查，如果程序超过设定flash大小的一半将会报错</li>
        <li>解决这个问题的方法也出奇的简单，直接把FLASH大小设定为实际可用FLASH大小的两倍即可</li>
    </ul>
<h2>flash布局的调整</h2>
    <ul>
        <li>如果EC的flash布局特性对你有用，这里介绍一些宏设定来调整EC的flash布局</li>
    </ul>